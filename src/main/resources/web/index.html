<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AllayMap - Minecraft Live Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-bg: rgba(26, 26, 46, 0.95);
            --text-primary: #f8f8f2;
            --text-secondary: #6272a4;
            --accent: #8be9fd;
            --success: #50fa7b;
            --warning: #ffb86c;
            --danger: #ff5555;
            --border: #44475a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg-color); }

        #map { height: 100%; width: 100%; z-index: 1; }

        /* 优化地图切片渲染，防止像素模糊 */
        .leaflet-tile {
            image-rendering: pixelated; /* Chrome/Edge */
            image-rendering: -moz-crisp-edges; /* Firefox */
        }

        /* 平滑玩家移动动画 */
        .leaflet-marker-icon {
            transition: transform 0.5s linear;
        }

        #controls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 1000;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            color: var(--text-primary);
            width: 240px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #controls h3 {
            margin-bottom: 8px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent);
        }

        #world-select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: #282a36;
            color: var(--text-primary);
            margin-bottom: 15px;
            outline: none;
            cursor: pointer;
        }

        #player-list {
            max-height: 300px;
            overflow-y: auto;
            /* 自定义滚动条 */
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

        #player-list::-webkit-scrollbar { width: 6px; }
        #player-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

        .player-item {
            display: flex;
            align-items: center;
            padding: 8px;
            cursor: pointer;
            border-radius: 6px;
            transition: background 0.2s;
            margin-bottom: 2px;
        }

        .player-item:hover { background: rgba(255,255,255,0.1); }
        .player-item.active { background: rgba(80, 250, 123, 0.15); border: 1px solid rgba(80, 250, 123, 0.3); }

        .player-avatar {
            width: 28px;
            height: 28px;
            background: var(--border);
            border-radius: 6px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--accent);
            overflow: hidden;
        }

        .player-avatar img { width: 100%; height: 100%; image-rendering: pixelated; }

        .player-info { display: flex; flex-direction: column; flex: 1; }
        .player-name { font-size: 14px; font-weight: 500; }
        .player-pos { font-size: 11px; color: var(--text-secondary); }

        .coords {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: var(--panel-bg);
            padding: 8px 12px;
            border-radius: 30px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            pointer-events: none;
            transition: opacity 0.3s;
        }

        /* Marker Styles */
        .player-marker-root { position: relative; }
        .player-head {
            background: var(--success);
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            border-radius: 4px;
            width: 20px;
            height: 20px;
        }

        .player-label {
            position: absolute;
            left: 50%;
            bottom: 28px;
            transform: translateX(-50%);
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            text-align: center;
            opacity: 0.9;
        }
        /* 小三角 */
        .player-label::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            margin-left: -4px;
            border-width: 4px 4px 0;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
        }

        .player-label .name { font-size: 12px; color: #fff; font-weight: bold; margin-bottom: 2px; }

        .health-bar {
            width: 100%;
            min-width: 40px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin: 0 auto;
        }

        .health-fill { height: 100%; transition: width 0.3s ease, background-color 0.3s; }
        .health-fill.high { background: var(--success); }
        .health-fill.medium { background: var(--warning); }
        .health-fill.low { background: var(--danger); }

        #share-btn {
            position: absolute;
            bottom: 60px; /* 位于坐标显示上方 */
            left: 20px;
            z-index: 1000;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--panel-bg);
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }

        #share-btn:hover {
            background: var(--border);
            transform: translateY(-2px);
            color: var(--accent);
        }

        #share-btn:active {
            transform: translateY(0);
        }

        /* 提示气泡 (默认隐藏) */
        #share-btn .tooltip {
            position: absolute;
            left: 50px;
            background: var(--success);
            color: #1a1a2e;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            transform: translateX(10px);
        }

        #share-btn.copied .tooltip {
            opacity: 1;
            transform: translateX(0);
        }
    </style>
</head>
<body>
<div id="map"></div>

<div id="controls">
    <h3>World</h3>
    <select id="world-select">
        <option value="" disabled selected>Select World</option>
    </select>

    <h3>Online Players</h3>
    <div id="player-list">
        <div style="padding:10px; color: #6272a4; font-size: 12px;">Waiting for data...</div>
    </div>
</div>

<button id="share-btn" title="Copy Link to Current View">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    <span class="tooltip">Link Copied!</span>
</button>

<div class="coords" id="coords" style="opacity: 0;">X: 0, Z: 0</div>

<script>
    class AllayMap {
        constructor() {
            // Config
            this.config = {
                tileSize: 512,
                maxZoom: 5,
                updateInterval: 1000,
                api: {
                    worlds: '/api/worlds',
                    players: '/api/players'
                }
            };

            // State
            this.state = {
                currentWorld: null,
                players: new Map(), // Stores data + markers
                listElements: new Map(), // Stores DOM elements for list
                isFetching: false
            };

            this.dom = {
                worldSelect: document.getElementById('world-select'),
                playerList: document.getElementById('player-list'),
                coords: document.getElementById('coords'),
                shareBtn: document.getElementById('share-btn')
            };

            this.initMap();
            this.bindEvents();
            this.startLoop();
        }

        initMap() {
            this.map = L.map('map', {
                crs: L.CRS.Simple,
                center: [0, 0],
                zoom: 2,
                minZoom: 0,
                maxZoom: this.config.maxZoom,
                zoomSnap: 0.5,
                zoomDelta: 0.5,
                attributionControl: false,
                preferCanvas: true
            });

            // Custom Tile Layer
            this.tileLayer = L.tileLayer('', {
                tileSize: this.config.tileSize,
                noWrap: true,
                bounds: [[-1000000, -1000000], [1000000, 1000000]],
                errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=' // 透明占位图
            });

            // Override getTileUrl dynamically
            this.tileLayer.getTileUrl = (coords) => {
                if (!this.state.currentWorld) return '';
                const z = Math.min(this.config.maxZoom, Math.max(0, this.config.maxZoom - coords.z));
                return `/tiles/${this.state.currentWorld}/${z}/${coords.x}_${coords.y}.png`;
            };

            this.tileLayer.addTo(this.map);
        }

        bindEvents() {
            // World Change
            this.dom.worldSelect.addEventListener('change', (e) => {
                const opt = e.target.selectedOptions[0];
                if (opt) {
                    this.setWorld(opt.value, +opt.dataset.x, +opt.dataset.z);
                }
            });

            this.dom.shareBtn.addEventListener('click', () => this.copyPermalink());

            // Coords Update (using requestAnimationFrame for performance)
            this.map.on('mousemove', (e) => {
                if (this.coordReq) cancelAnimationFrame(this.coordReq);
                this.coordReq = requestAnimationFrame(() => {
                    const x = Math.floor(e.latlng.lng);
                    const z = -Math.floor(e.latlng.lat);
                    this.dom.coords.textContent = `X: ${x}, Z: ${z}`;
                    this.dom.coords.style.opacity = '1';
                });
            });

            this.map.on('mouseout', () => {
                this.dom.coords.style.opacity = '0';
            });
        }

        copyPermalink() {
            const center = this.map.getCenter();
            const zoom = this.map.getZoom();
            const x = Math.round(center.lng);
            const z = Math.round(-center.lat); // Leaflet Lat 是反转的 Z
            const world = this.state.currentWorld;

            // 构建 URL
            const url = new URL(window.location.href);
            url.searchParams.set('world', world);
            url.searchParams.set('x', x);
            url.searchParams.set('z', z);
            url.searchParams.set('zoom', zoom);

            // 复制到剪贴板
            navigator.clipboard.writeText(url.toString()).then(() => {
                // 显示成功提示
                this.dom.shareBtn.classList.add('copied');
                setTimeout(() => {
                    this.dom.shareBtn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy URL to clipboard');
            });
        }

        async startLoop() {
            await this.loadWorlds();
            this.updatePlayers(); // Initial call
            setInterval(() => this.updatePlayers(), this.config.updateInterval);
        }

        async loadWorlds() {
            try {
                const res = await fetch(this.config.api.worlds);
                if (!res.ok) throw new Error('API Error');
                const data = await res.json();

                this.dom.worldSelect.innerHTML = '';

                if (!data.worlds || data.worlds.length === 0) {
                    this.dom.worldSelect.innerHTML = '<option>No worlds found</option>';
                    return;
                }

                // 解析 URL 参数
                const params = new URLSearchParams(window.location.search);
                const paramWorld = params.get('world');
                const paramX = params.get('x');
                const paramZ = params.get('z');
                const paramZoom = params.get('zoom');

                let initialWorld = null;
                let initialX = 0;
                let initialZ = 0;
                let initialZoom = 2; // 默认缩放

                data.worlds.forEach((w, index) => {
                    const opt = document.createElement('option');
                    opt.value = w.id;
                    opt.textContent = w.dimensionName ? `${w.name} (${w.dimensionName})` : w.name;
                    opt.dataset.x = w.spawn.x;
                    opt.dataset.z = w.spawn.z;
                    this.dom.worldSelect.appendChild(opt);

                    // 逻辑：如果 URL 指定了世界且存在，则使用它；否则默认使用第一个世界
                    if (paramWorld && w.id === paramWorld) {
                        initialWorld = w.id;
                        // 如果 URL 有坐标，用 URL 的，否则用出生点
                        initialX = paramX ? parseFloat(paramX) : w.spawn.x;
                        initialZ = paramZ ? parseFloat(paramZ) : w.spawn.z;
                        initialZoom = paramZoom ? parseFloat(paramZoom) : this.config.maxZoom;

                        // 同步 Select 的选中状态
                        setTimeout(() => { this.dom.worldSelect.value = w.id; }, 0);
                    } else if (index === 0 && !initialWorld) {
                        // 默认回退
                        initialWorld = w.id;
                        initialX = w.spawn.x;
                        initialZ = w.spawn.z;
                    }
                });

                // 初始化地图视图
                if (initialWorld) {
                    this.setWorld(initialWorld, initialX, initialZ, initialZoom);
                }

            } catch (e) {
                console.error('World load failed', e);
                setTimeout(() => this.loadWorlds(), 5000);
            }
        }

        setWorld(id, x, z, zoom = 2) {
            // 即使是同一个世界，如果是通过 URL 跳转来的，我们也允许重新定位视图
            // 但如果是普通切换，我们通常只想加载瓦片

            const isWorldChanged = this.state.currentWorld !== id;
            this.state.currentWorld = id;

            // 刷新 Select UI (防止程序调用 setWorld 时 UI 没变)
            if (this.dom.worldSelect.value !== id) {
                this.dom.worldSelect.value = id;
            }

            if (isWorldChanged) {
                this.tileLayer.redraw();
                this.refreshMarkerVisibility();
            }

            // 移动视角
            this.map.setView([-z, x], zoom);
        }

        async updatePlayers() {
            if (this.state.isFetching) return;
            this.state.isFetching = true;

            try {
                const res = await fetch(this.config.api.players);
                const data = await res.json();
                const players = data.players || [];
                const activeUuids = new Set();

                // 1. Update or Create
                players.forEach(p => {
                    activeUuids.add(p.uuid);
                    this.handlePlayerUpdate(p);
                });

                // 2. Remove disconnected
                this.state.players.forEach((val, uuid) => {
                    if (!activeUuids.has(uuid)) {
                        this.removePlayer(uuid);
                    }
                });

                // 3. Update List Empty State
                if (players.length === 0 && this.dom.playerList.children.length > 0) {
                    this.dom.playerList.innerHTML = '<div style="padding:10px; color: #6272a4; font-size: 12px;">No players online</div>';
                } else if (players.length > 0 && this.dom.playerList.querySelector('div').textContent.includes('No players')) {
                    this.dom.playerList.innerHTML = '';
                }

            } catch (e) {
                console.warn('Player update failed', e);
            } finally {
                this.state.isFetching = false;
            }
        }

        handlePlayerUpdate(p) {
            // --- Map Marker Logic ---
            if (this.state.players.has(p.uuid)) {
                // Update existing
                const obj = this.state.players.get(p.uuid);
                const oldP = obj.data;

                // Move marker (Leaflet + CSS transition handles smoothing)
                obj.marker.setLatLng([-p.z, p.x]);

                // Only update DOM icon if health/name changed to save performance
                if (Math.round(p.health) !== Math.round(oldP.health) || p.name !== oldP.name) {
                    obj.marker.setIcon(this.createIcon(p));
                }

                // Handle World Change
                if (p.world !== oldP.world) {
                    obj.data.world = p.world;
                    this.refreshMarkerVisibility();
                }

                // Store new data
                obj.data = p;
            } else {
                // Create new
                const marker = L.marker([-p.z, p.x], {
                    icon: this.createIcon(p)
                });

                if (p.world === this.state.currentWorld) {
                    marker.addTo(this.map);
                }

                this.state.players.set(p.uuid, { marker, data: p });
            }

            // --- Sidebar List Logic (Diffing) ---
            this.updatePlayerListItem(p);
        }

        removePlayer(uuid) {
            // Remove marker
            const obj = this.state.players.get(uuid);
            if (obj && obj.marker) this.map.removeLayer(obj.marker);
            this.state.players.delete(uuid);

            // Remove list item
            const el = this.state.listElements.get(uuid);
            if (el) {
                el.remove();
                this.state.listElements.delete(uuid);
            }
        }

        updatePlayerListItem(p) {
            let el = this.state.listElements.get(p.uuid);

            // If list was cleared by "No players" message, reset mapping
            if (!document.contains(el)) el = null;

            if (!el) {
                // Create Item
                el = document.createElement('div');
                el.className = 'player-item';
                el.onclick = () => this.focusPlayer(p.uuid);
                this.dom.playerList.appendChild(el);
                this.state.listElements.set(p.uuid, el);
            }

            // Update Content
            const isCurrentWorld = p.world === this.state.currentWorld;
            el.className = `player-item ${isCurrentWorld ? 'active' : ''}`;
            el.innerHTML = `
                    <div class="player-avatar">
                        ${p.name.charAt(0).toUpperCase()}
                    </div>
                    <div class="player-info">
                        <div class="player-name">${this.escape(p.name)}</div>
                        <div class="player-pos">
                            ${isCurrentWorld ? `X: ${Math.round(p.x)} Z: ${Math.round(p.z)}` : `in ${p.world}`}
                        </div>
                    </div>
                `;
        }

        refreshMarkerVisibility() {
            this.state.players.forEach(({marker, data}) => {
                if (data.world === this.state.currentWorld) {
                    if (!this.map.hasLayer(marker)) marker.addTo(this.map);
                } else {
                    if (this.map.hasLayer(marker)) this.map.removeLayer(marker);
                }
            });
        }

        createIcon(p) {
            const hpPct = Math.min(100, Math.max(0, (p.health / p.maxHealth) * 100));
            let colorClass = 'high';
            if (hpPct < 50) colorClass = 'medium';
            if (hpPct < 20) colorClass = 'low';

            return L.divIcon({
                className: 'player-marker-root',
                html: `
                        <div class="player-label">
                            <div class="name">${this.escape(p.name)}</div>
                            <div class="health-bar">
                                <div class="health-fill ${colorClass}" style="width: ${hpPct}%"></div>
                            </div>
                        </div>
                        <div class="player-head"></div>
                    `,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
        }

        focusPlayer(uuid) {
            const obj = this.state.players.get(uuid);
            if (!obj) return;

            const { data } = obj;
            if (data.world !== this.state.currentWorld) {
                this.dom.worldSelect.value = data.world;
                // Trigger change event manually or call setWorld directly
                // Find spawn coords for that world is tricky without world list map,
                // so we just switch world ID and let the next update loop handle marker visibility,
                // then fly to player.
                this.state.currentWorld = data.world;
                this.tileLayer.redraw();
                this.refreshMarkerVisibility();
            }

            this.map.flyTo([-data.z, data.x], this.config.maxZoom);
        }

        escape(str) {
            return str.replace(/[&<>"']/g, function(m) {
                return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m];
            });
        }
    }

    // Initialize App
    document.addEventListener('DOMContentLoaded', () => {
        window.app = new AllayMap();
    });
</script>
</body>
</html>
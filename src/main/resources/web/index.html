<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AllayMap</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        #map { height: 100%; width: 100%; background: #1a1a2e; }
        .leaflet-tile {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(26, 26, 46, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            min-width: 200px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        #controls h3 {
            margin-bottom: 10px;
            font-size: 14px;
            color: #8be9fd;
        }

        #world-select {
            width: 100%;
            padding: 8px;
            border: 1px solid #44475a;
            border-radius: 4px;
            background: #282a36;
            color: #f8f8f2;
            margin-bottom: 10px;
        }

        #player-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .player-item {
            display: flex;
            align-items: center;
            padding: 5px;
            cursor: pointer;
            border-radius: 4px;
        }

        .player-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .player-icon {
            width: 24px;
            height: 24px;
            background: #50fa7b;
            border-radius: 50%;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .coords {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(26, 26, 46, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            color: #fff;
            font-family: monospace;
            font-size: 12px;
        }

        .player-marker {
            background: #50fa7b;
            border: 3px solid #fff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
        }

        .player-label {
            position: absolute;
            left: 22px;
            top: -10px;
            white-space: nowrap;
            background: rgba(26, 26, 46, 0.9);
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 14px;
            color: #fff;
            pointer-events: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }

        .player-label .name {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .player-label .health-bar {
            width: 70px;
            height: 6px;
            background: #44475a;
            border-radius: 3px;
            overflow: hidden;
        }

        .player-label .health-fill {
            height: 100%;
            background: #50fa7b;
            transition: width 0.3s ease;
        }

        .player-label .health-fill.low {
            background: #ffb86c;
        }

        .player-label .health-fill.critical {
            background: #ff5555;
        }

        .status-message {
            color: #6272a4;
            font-size: 12px;
            padding: 5px 0;
        }

        .status-message.error {
            color: #ff5555;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div id="controls">
        <h3>World</h3>
        <select id="world-select">
            <option value="">Loading...</option>
        </select>

        <h3>Players</h3>
        <div id="player-list">
            <div class="status-message">Loading...</div>
        </div>
    </div>

    <div class="coords" id="coords">X: 0, Z: 0</div>

    <script>
        // Configuration
        const DISPLAY_TILE_SIZE = 512;
        const MAX_TILE_ZOOM = 5;
        const PLAYER_UPDATE_INTERVAL = 1000;
        const COORD_UPDATE_THROTTLE = 50; // ms

        // State
        let currentWorld = null;
        let tileLayer = null;
        const playerMarkers = new Map();
        let isUpdatingPlayers = false;
        let lastCoordUpdate = 0;

        // Initialize map
        const map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: 0,
            maxZoom: MAX_TILE_ZOOM,
            zoomSnap: 1,
            zoomDelta: 1
        }).setView([0, 0], 2);

        // Custom tile layer
        class MinecraftTileLayer extends L.TileLayer {
            getTileUrl(coords) {
                if (!currentWorld) return '';
                const tileZoom = Math.min(MAX_TILE_ZOOM, Math.max(0, MAX_TILE_ZOOM - coords.z));
                return `/tiles/${currentWorld}/${tileZoom}/${coords.x}_${coords.y}.png`;
            }
        }

        // Load worlds
        async function loadWorlds() {
            const select = document.getElementById('world-select');

            try {
                const response = await fetch('/api/worlds');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();

                select.innerHTML = '';

                if (data.worlds.length === 0) {
                    select.innerHTML = '<option value="">No worlds available</option>';
                    return;
                }

                data.worlds.forEach(world => {
                    const option = document.createElement('option');
                    option.value = world.id;
                    option.textContent = `${world.name} (${world.dimensionName})`;
                    option.dataset.spawnX = world.spawn.x;
                    option.dataset.spawnZ = world.spawn.z;
                    select.appendChild(option);
                });

                selectWorld(data.worlds[0].id, data.worlds[0].spawn.x, data.worlds[0].spawn.z);
            } catch (e) {
                console.error('Failed to load worlds:', e);
                select.innerHTML = '<option value="">Failed to load worlds</option>';
                // Retry after 5 seconds
                setTimeout(loadWorlds, 5000);
            }
        }

        // Select a world
        function selectWorld(worldId, spawnX = 0, spawnZ = 0) {
            currentWorld = worldId;

            if (tileLayer) {
                map.removeLayer(tileLayer);
            }

            tileLayer = new MinecraftTileLayer('', {
                tileSize: DISPLAY_TILE_SIZE,
                noWrap: true,
                bounds: [[-1000000, -1000000], [1000000, 1000000]]
            });

            tileLayer.addTo(map);
            map.setView([-spawnZ, spawnX], 2);

            // Update player markers for new world
            updatePlayerMarkersVisibility();
        }

        // Update only marker visibility when world changes
        function updatePlayerMarkersVisibility() {
            playerMarkers.forEach((markerData, uuid) => {
                if (markerData.world === currentWorld) {
                    if (!map.hasLayer(markerData.marker)) {
                        markerData.marker.addTo(map);
                    }
                } else {
                    if (map.hasLayer(markerData.marker)) {
                        map.removeLayer(markerData.marker);
                    }
                }
            });
        }

        // Create HTML for player marker with name and health bar
        function createPlayerMarkerHtml(player) {
            const healthPercent = (player.health / player.maxHealth) * 100;
            const healthClass = healthPercent <= 25 ? 'critical' : (healthPercent <= 50 ? 'low' : '');
            return `
                <div class="player-marker"></div>
                <div class="player-label">
                    <div class="name">${escapeHtml(player.name)}</div>
                    <div class="health-bar">
                        <div class="health-fill ${healthClass}" style="width: ${healthPercent}%"></div>
                    </div>
                </div>
            `;
        }

        // Update marker label with new health data
        function updateMarkerLabel(marker, player) {
            const healthPercent = (player.health / player.maxHealth) * 100;
            const healthClass = healthPercent <= 25 ? 'critical' : (healthPercent <= 50 ? 'low' : '');
            marker.setIcon(L.divIcon({
                className: '',
                html: createPlayerMarkerHtml(player),
                iconSize: [12, 12],
                iconAnchor: [6, 6]
            }));
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Update players with incremental updates
        async function updatePlayers() {
            if (isUpdatingPlayers) return;
            isUpdatingPlayers = true;

            const playerList = document.getElementById('player-list');

            try {
                const response = await fetch('/api/players');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();

                const currentPlayerUuids = new Set();

                // Update or add players
                data.players.forEach(player => {
                    currentPlayerUuids.add(player.uuid);

                    if (playerMarkers.has(player.uuid)) {
                        // Update existing marker position
                        const markerData = playerMarkers.get(player.uuid);
                        markerData.marker.setLatLng([-player.z, player.x]);
                        markerData.marker.setPopupContent(
                            `<b>${player.name}</b><br>X: ${player.x}, Y: ${player.y}, Z: ${player.z}<br>Health: ${Math.round(player.health)}/${Math.round(player.maxHealth)}`
                        );
                        // Update health bar
                        updateMarkerLabel(markerData.marker, player);
                        markerData.world = player.world;
                        markerData.player = player;

                        // Update visibility
                        if (player.world === currentWorld && !map.hasLayer(markerData.marker)) {
                            markerData.marker.addTo(map);
                        } else if (player.world !== currentWorld && map.hasLayer(markerData.marker)) {
                            map.removeLayer(markerData.marker);
                        }
                    } else {
                        // Create new marker
                        const marker = L.marker([-player.z, player.x], {
                            icon: L.divIcon({
                                className: '',
                                html: createPlayerMarkerHtml(player),
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        }).bindPopup(`<b>${player.name}</b><br>X: ${player.x}, Y: ${player.y}, Z: ${player.z}<br>Health: ${Math.round(player.health)}/${Math.round(player.maxHealth)}`);

                        if (player.world === currentWorld) {
                            marker.addTo(map);
                        }

                        playerMarkers.set(player.uuid, { marker, world: player.world, player });
                    }
                });

                // Remove disconnected players
                playerMarkers.forEach((markerData, uuid) => {
                    if (!currentPlayerUuids.has(uuid)) {
                        map.removeLayer(markerData.marker);
                        playerMarkers.delete(uuid);
                    }
                });

                // Update player list UI
                if (data.players.length === 0) {
                    playerList.innerHTML = '<div class="status-message">No players online</div>';
                } else {
                    playerList.innerHTML = '';
                    data.players.forEach(player => {
                        const item = document.createElement('div');
                        item.className = 'player-item';
                        item.innerHTML = `
                            <div class="player-icon">${player.name.charAt(0).toUpperCase()}</div>
                            <span>${player.name}</span>
                        `;
                        item.onclick = () => {
                            if (player.world === currentWorld) {
                                map.setView([-player.z, player.x], MAX_TILE_ZOOM);
                            } else {
                                document.getElementById('world-select').value = player.world;
                                selectWorld(player.world, player.x, player.z);
                            }
                        };
                        playerList.appendChild(item);
                    });
                }
            } catch (e) {
                console.error('Failed to update players:', e);
                playerList.innerHTML = '<div class="status-message error">Failed to load players</div>';
            } finally {
                isUpdatingPlayers = false;
            }
        }

        // Throttled coordinate update
        map.on('mousemove', (e) => {
            const now = Date.now();
            if (now - lastCoordUpdate < COORD_UPDATE_THROTTLE) return;
            lastCoordUpdate = now;

            const x = Math.floor(e.latlng.lng);
            const z = -Math.floor(e.latlng.lat);
            document.getElementById('coords').textContent = `X: ${x}, Z: ${z}`;
        });

        // World select handler
        document.getElementById('world-select').addEventListener('change', (e) => {
            const option = e.target.selectedOptions[0];
            if (option && option.value) {
                selectWorld(option.value, parseInt(option.dataset.spawnX) || 0, parseInt(option.dataset.spawnZ) || 0);
            }
        });

        // Initialize
        loadWorlds();
        updatePlayers();
        setInterval(updatePlayers, PLAYER_UPDATE_INTERVAL);
    </script>
</body>
</html>
